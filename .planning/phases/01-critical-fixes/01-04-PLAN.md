# Phase 1, Plan 4: Error Handling & Security Infrastructure

## Objective

Implement critical error handling and security infrastructure: (1) Error Boundary to prevent blank screen crashes, (2) Remove console logging in production builds that exposes sensitive check data, and (3) Add Content Security Policy to prevent XSS attacks.

These fixes establish foundational security and reliability infrastructure for the application.

## Context

Current issues (from audit):
- No error boundary - any uncaught error results in blank white screen
- console.error in NotFound.tsx exposes user navigation in production
- No CSP headers - vulnerable to XSS despite input sanitization
- Production builds include console.log statements with check data

**Source**: analysis/remediation-plan.md (Fix 1.5, 1.6, 1.7)
**Priority**: CRITICAL - Application stability and security
**Effort**: Medium

Files to examine:
- @src/App.tsx (to add error boundary)
- @src/pages/NotFound.tsx (console.error issue)
- @vite.config.ts (build configuration)
- @index.html (CSP meta tag)

## Tasks

### Task 1: Create Error Boundary component
**Type**: new-file
**Files**: src/components/ErrorBoundary.tsx
**Action**:
Create class component with error catching:

```typescript
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Button } from '@/components/ui/button';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  handleReset = () => {
    this.setState({ hasError: false, error: null });
    window.location.href = '/';
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
          <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-6 text-center">
            <div className="text-red-600 text-5xl mb-4">⚠️</div>
            <h1 className="text-2xl font-bold text-gray-900 mb-2">
              Something went wrong
            </h1>
            <p className="text-gray-600 mb-4">
              An unexpected error occurred. Please try refreshing the page.
            </p>
            {this.state.error && (
              <details className="text-left mb-4 p-3 bg-gray-50 rounded text-sm">
                <summary className="cursor-pointer font-medium text-gray-700">
                  Error Details
                </summary>
                <pre className="mt-2 text-xs overflow-auto">
                  {this.state.error.toString()}
                </pre>
              </details>
            )}
            <Button onClick={this.handleReset} className="w-full">
              Return to Home
            </Button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
```

**Verify**:
- [ ] File created at src/components/ErrorBoundary.tsx
- [ ] Class component with proper lifecycle methods
- [ ] Nice error UI with reset button
- [ ] No TypeScript errors

**Done**: ☐

---

### Task 2: Wrap App in Error Boundary
**Type**: modify
**Files**: src/App.tsx
**Action**:
1. Import ErrorBoundary:
   ```typescript
   import ErrorBoundary from '@/components/ErrorBoundary';
   ```

2. Wrap entire app:
   ```typescript
   const App = () => (
     <ErrorBoundary>
       <QueryClientProvider client={queryClient}>
         <TooltipProvider>
           <Toaster />
           <Sonner />
           <BrowserRouter>
             <Routes>
               <Route path="/" element={<Index />} />
               <Route path="*" element={<NotFound />} />
             </Routes>
           </BrowserRouter>
         </TooltipProvider>
       </QueryClientProvider>
     </ErrorBoundary>
   );
   ```

**Verify**:
- [ ] ErrorBoundary wraps QueryClientProvider
- [ ] All app content is protected
- [ ] No syntax errors

**Done**: ☐

---

### Task 3: Test Error Boundary
**Type**: testing
**Action**:
1. Add temporary error in CheckPreview.tsx:
   ```typescript
   // At top of component, add:
   if (amount === '999') throw new Error('Test error boundary');
   ```

2. Test error boundary:
   - Enter amount "999" in form
   - Verify error boundary catches error
   - Verify nice error UI appears
   - Verify "Return to Home" button works
   - Verify error logged to console

3. Remove test code after verification

**Verify**:
- [ ] Error boundary catches errors
- [ ] Fallback UI displays correctly
- [ ] Reset button works
- [ ] Error details are expandable
- [ ] Console shows error details

**Done**: ☐

---

### Task 4: Conditionalize console logging in NotFound
**Type**: modify
**Files**: src/pages/NotFound.tsx
**Action**:
Wrap console.error in development check:

```typescript
useEffect(() => {
  if (import.meta.env.DEV) {
    console.error(
      "404 Error: User attempted to access non-existent route:",
      location.pathname
    );
  }
}, [location.pathname]);
```

**Verify**:
- [ ] Console.error only runs in development
- [ ] Production builds don't log 404s
- [ ] Development mode still logs for debugging

**Done**: ☐

---

### Task 5: Configure production build to strip console
**Type**: modify
**Files**: vite.config.ts
**Action**:
1. Add build configuration:
   ```typescript
   export default defineConfig(({ mode }) => ({
     server: {
       host: "::",
       port: 8080,
     },
     plugins: [
       react(),
       mode === 'development' && componentTagger(),
     ].filter(Boolean),
     resolve: {
       alias: {
         "@": path.resolve(__dirname, "./src"),
       },
     },
     build: {
       minify: 'terser',
       terserOptions: {
         compress: {
           drop_console: mode === 'production',
           drop_debugger: true,
         },
       },
     },
   }));
   ```

2. Install terser if not already installed:
   ```bash
   npm install --save-dev terser
   ```

**Verify**:
- [ ] Build config includes terserOptions
- [ ] drop_console only in production
- [ ] terser installed

**Done**: ☐

---

### Task 6: Test console removal in production build
**Type**: testing
**Action**:
1. Build production bundle:
   ```bash
   npm run build
   ```

2. Check dist files:
   ```bash
   grep -r "console\." dist/assets/*.js
   ```

3. Preview production build:
   ```bash
   npm run preview
   ```

4. Test in browser:
   - Open DevTools console
   - Trigger various actions
   - Verify no console logs appear
   - Verify app works normally

**Verify**:
- [ ] Production build completes successfully
- [ ] dist files don't contain console statements
- [ ] Preview shows no console logs
- [ ] App functionality unchanged

**Done**: ☐

---

### Task 7: Add Content Security Policy
**Type**: modify
**Files**: index.html
**Action**:
Add CSP meta tag in `<head>` section:

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://cdn.gpteng.co; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self'; frame-ancestors 'none';">
```

**Explanation**:
- `default-src 'self'`: Only load resources from same origin
- `script-src 'self' https://cdn.gpteng.co`: Allow scripts from self + Lovable CDN
- `style-src 'self' 'unsafe-inline'`: Allow inline styles (Tailwind requires this)
- `img-src 'self' data: https:`: Allow images from self, data URIs, and HTTPS
- `font-src 'self' data:`: Allow fonts from self and data URIs
- `connect-src 'self'`: Only allow fetch/XHR to same origin
- `frame-ancestors 'none'`: Prevent embedding in iframes (clickjacking protection)

**Verify**:
- [ ] CSP meta tag added to index.html
- [ ] Tag is in <head> section
- [ ] Proper formatting

**Done**: ☐

---

### Task 8: Test CSP implementation
**Type**: testing
**Action**:
1. Start dev server:
   ```bash
   npm run dev
   ```

2. Open browser DevTools Console
3. Check for CSP violations
4. Test all functionality:
   - Page loads correctly
   - All styles apply
   - Images load
   - Fonts load
   - Print preview works
   - Form submission works

5. Test CSP effectiveness:
   - Try to inject inline script in DevTools:
     ```javascript
     const script = document.createElement('script');
     script.textContent = 'alert("XSS")';
     document.body.appendChild(script);
     ```
   - Should be blocked by CSP

6. Use CSP Evaluator:
   - Visit: https://csp-evaluator.withgoogle.com/
   - Paste the CSP policy
   - Review recommendations

**Verify**:
- [ ] No CSP violations in console
- [ ] All functionality works
- [ ] Fonts and images load
- [ ] Print functionality works
- [ ] Inline script injection blocked
- [ ] CSP Evaluator shows acceptable rating

**Done**: ☐

---

### Task 9: Document production security headers
**Type**: documentation
**Action**:
Create security headers documentation for deployment.

Add to README.md or create DEPLOYMENT.md:

```markdown
## Production Security Headers

Add these headers to your web server configuration:

### Nginx:
```nginx
add_header Content-Security-Policy "default-src 'self'; script-src 'self' https://cdn.gpteng.co; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self'; frame-ancestors 'none';" always;
add_header X-Frame-Options "DENY" always;
add_header X-Content-Type-Options "nosniff" always;
add_header Referrer-Policy "strict-origin-when-cross-origin" always;
add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;
```

### Apache (.htaccess):
```apache
Header set Content-Security-Policy "default-src 'self'; script-src 'self' https://cdn.gpteng.co; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self'; frame-ancestors 'none';"
Header set X-Frame-Options "DENY"
Header set X-Content-Type-Options "nosniff"
Header set Referrer-Policy "strict-origin-when-cross-origin"
Header set Permissions-Policy "geolocation=(), microphone=(), camera=()"
```
```

**Verify**:
- [ ] Documentation created
- [ ] Both Nginx and Apache examples provided
- [ ] Headers explained

**Done**: ☐

## Verification

Before declaring this plan complete, verify:

1. **Error Boundary**:
   - [ ] Component created and working
   - [ ] Catches errors without crashing app
   - [ ] Shows user-friendly error UI
   - [ ] Reset button works

2. **Console Logging**:
   - [ ] Development mode shows console logs
   - [ ] Production builds strip console logs
   - [ ] No sensitive data in production console

3. **Content Security Policy**:
   - [ ] CSP meta tag added
   - [ ] No CSP violations in console
   - [ ] All functionality works with CSP
   - [ ] XSS attempts blocked

4. **Documentation**:
   - [ ] Server security headers documented
   - [ ] Deployment instructions clear

## Success Criteria

- [ ] ErrorBoundary.tsx created and working
- [ ] App.tsx wrapped in ErrorBoundary
- [ ] Error boundary tested and catches errors
- [ ] NotFound.tsx console.error only in dev
- [ ] vite.config.ts strips console in production
- [ ] terser installed
- [ ] Production build verified (no console statements)
- [ ] CSP meta tag added to index.html
- [ ] CSP tested (no violations, all features work)
- [ ] XSS injection blocked by CSP
- [ ] Security headers documented for production
- [ ] No TypeScript compilation errors
- [ ] All manual tests pass

## Output

Create `01-04-SUMMARY.md` documenting:

### What Was Done
- ErrorBoundary component created
- Production console logging removed
- CSP implemented and tested
- Security headers documented

### Testing Results
- Error boundary test results
- Production build verification
- CSP violation checks
- XSS injection test results

### Deviations
- Any changes from plan
- Auto-fix rules applied
- Justification

### Commits
- Commit hashes and descriptions

### Next Steps
- Phase 1 complete! All 4 critical plans executed
- Ready to begin Phase 2 (High Priority Fixes)
- Next: Create Phase 2 plans or start with 02-01-PLAN.md
